<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Perp Insights — Multi-Exchange</title>

  <style>
    body { font-family: Arial, sans-serif; background:#0f172a; color:#e5e7eb; padding:24px; }
    h1 { margin: 0 0 8px 0; }
    .sub { color:#9ca3af; margin-bottom:16px; line-height: 1.45; }
    .card { background:#111827; border-radius:12px; padding:16px; max-width: 1200px; margin-bottom:16px; }
    table { width:100%; border-collapse: collapse; }
    th, td { padding: 12px 10px; border-bottom: 1px solid #1f2937; }
    th { color:#cbd5e1; font-weight: 600; text-align:left; }
    .asset { font-weight: 700; }
    .right { text-align:right; }
    .muted { color:#9ca3af; font-size:12px; margin-top:10px; }
    .pill {
      display:inline-block; padding:3px 8px; border-radius:999px;
      background:#0b1220; border:1px solid #1f2937;
      font-size:12px; color:#cbd5e1; margin-right:6px;
    }
    .ok { color:#86efac; }
    .err { color:#fca5a5; }
    .pos { color:#86efac; }
    .neg { color:#fca5a5; }
    .dash-title { display:flex; align-items:baseline; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .dash-title h2 { margin: 0; font-size: 16px; color:#e5e7eb; }

    /* Row highlight when spread >= 5bp */
    .hot {
      background: rgba(250, 204, 21, 0.12);
      outline: 1px solid rgba(250, 204, 21, 0.35);
      outline-offset: -1px;
    }

    /* Tabs */
    .tabs { display:flex; gap:8px; margin: 14px 0 16px 0; flex-wrap:wrap; }
    .tab-btn {
      cursor:pointer;
      padding:8px 12px;
      border-radius:10px;
      border:1px solid #1f2937;
      background:#0b1220;
      color:#cbd5e1;
      font-size:14px;
    }
    .tab-btn.active { background:#111827; border-color:#334155; color:#e5e7eb; }
    .tab-panel { display:none; }
    .tab-panel.active { display:block; }

    /* Filters */
    .filters { display:flex; gap:14px; flex-wrap:wrap; align-items:flex-start; }
    .filter-box { border:1px solid #1f2937; border-radius:12px; padding:12px; background:#0b1220; }
    .filter-title { font-size:12px; color:#cbd5e1; margin:0 0 8px 0; font-weight:700; }
    .chk { display:flex; gap:8px; align-items:center; margin:6px 0; font-size:13px; color:#e5e7eb; }
    .actions { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .btn {
      cursor:pointer;
      padding:10px 12px;
      border-radius:10px;
      border:1px solid #1f2937;
      background:#0b1220;
      color:#e5e7eb;
      font-size:14px;
    }

    /* Inputs */
    .grid { display:grid; gap:12px; }
    .grid-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    .grid-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
    @media (max-width: 980px) { .grid-3 { grid-template-columns: 1fr; } }
    @media (max-width: 820px) { .grid-2 { grid-template-columns: 1fr; } }

    label { display:block; font-size:12px; color:#cbd5e1; margin-bottom:6px; }
    input, select {
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid #1f2937;
      background:#0b1220;
      color:#e5e7eb;
      outline:none;
    }
    .kpi {
      display:flex; justify-content:space-between; align-items:center;
      padding:10px 12px; border-radius:12px; border:1px solid #1f2937; background:#0b1220;
    }
    .kpi .v { font-weight:700; }
  </style>
</head>

<body>
  <h1>Perp Insights</h1>
  <div class="sub">
    <span class="pill">Hyperliquid</span>
    <span class="pill">Aster</span>
    <span class="pill">Kraken Futures</span>
    <span class="pill">OKX</span><br/>
    Spread bps uses: <b>10,000 × (maxPrice − minPrice) / minPrice</b><br/>
    Prices refresh every <b>3s</b> · Funding refresh every <b>60s</b>
  </div>

  <div class="card">
    <div class="dash-title">
      <h2>Filters</h2>
      <div class="muted" id="filterStatus">Choose exchanges + coins, then “Apply filters”.</div>
    </div>

    <div class="filters" style="margin-top:12px;">
      <div class="filter-box">
        <div class="filter-title">Exchanges</div>
        <div id="exchChecks"></div>
        <div class="actions" style="margin-top:8px;">
          <button class="btn" id="exAll">Select all</button>
          <button class="btn" id="exNone">Clear</button>
        </div>
      </div>

      <div class="filter-box">
        <div class="filter-title">Coins</div>
        <div id="coinChecks" style="max-height:220px; overflow:auto; padding-right:8px;"></div>
        <div class="actions" style="margin-top:8px;">
          <button class="btn" id="cAll">Select all</button>
          <button class="btn" id="cNone">Clear</button>
        </div>
      </div>

      <div class="filter-box" style="min-width:240px;">
        <div class="filter-title">Actions</div>
        <div class="actions">
          <button class="btn" id="applyFilters">Apply filters</button>
          <button class="btn" id="resetFilters">Reset defaults</button>
        </div>
        <div class="muted" style="margin-top:10px;">
          Defaults: all exchanges + all coins.
        </div>
      </div>
    </div>
  </div>

  <div class="tabs">
    <button class="tab-btn active" data-tab="prices">Prices</button>
    <button class="tab-btn" data-tab="funding">Funding</button>
    <button class="tab-btn" data-tab="arb">Arb PnL Estimator</button>
    <button class="tab-btn" data-tab="fundarb">Funding rate arb calculator</button>
    <button class="tab-btn" data-tab="daily">Daily Insights</button>
  </div>

  <!-- PRICES TAB -->
  <div id="tab-prices" class="tab-panel active">
    <div class="card">
      <div class="dash-title">
        <h2>Prices</h2>
        <div class="muted" id="priceStatus">Loading…</div>
      </div>

      <table>
        <thead id="pricesHead"></thead>
        <tbody id="priceRows"></tbody>
      </table>

      <div class="muted" id="pricesNote">
        <b>Row will highlight when price spread across selected exchanges exceeds or equals 5bp</b><br/>
        “24h High (bps)” is the largest spread observed in the last 24h (stored in your browser).
      </div>
    </div>
  </div>

  <!-- FUNDING TAB -->
  <div id="tab-funding" class="tab-panel">
    <div class="card">
      <div class="dash-title">
        <h2>Funding Rates</h2>
        <div class="muted" id="fundingStatus">Loading…</div>
      </div>

      <table>
        <thead id="fundingHead"></thead>
        <tbody id="fundingRows"></tbody>
      </table>

      <div class="muted">
        365-day is normalised as: <b>rate_per_window × (365×24 / interval_hours)</b>.
      </div>
    </div>
  </div>

  <!-- ARB PNL TAB -->
  <div id="tab-arb" class="tab-panel">
    <div class="card">
      <div class="dash-title">
        <h2>Arb PnL Estimator</h2>
        <div class="muted">Pick Buy + Sell exchanges (uses live prices)</div>
      </div>

      <div class="grid grid-2" style="margin-top:12px;">
        <div>
          <label>Asset</label>
          <select id="arbAsset"></select>
        </div>
        <div>
          <label>Notional (USD)</label>
          <input id="arbNotional" type="number" value="100000" min="0" step="1000" />
        </div>

        <div>
          <label>Buy exchange</label>
          <select id="arbBuyEx"></select>
        </div>
        <div>
          <label>Sell exchange</label>
          <select id="arbSellEx"></select>
        </div>

        <div>
          <label>Target convergence (bps)</label>
          <input id="arbConvBps" type="number" value="5" step="0.1" />
        </div>
        <div>
          <label>Total costs (bps) — fees + slippage</label>
          <input id="arbCostsBps" type="number" value="3" step="0.1" />
        </div>
      </div>

      <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;">
        <button class="btn" id="arbRecalc">Recalculate</button>
        <div class="muted">Gross ≈ Notional × (convergence bps / 10,000)</div>
      </div>

      <div class="grid grid-2" style="margin-top:14px;">
        <div class="kpi"><div>Current buy/sell spread (bps)</div><div class="v" id="arbCurBps">—</div></div>
        <div class="kpi"><div>Gross PnL (USD)</div><div class="v" id="arbGross">—</div></div>
        <div class="kpi"><div>Costs (USD)</div><div class="v" id="arbCosts">—</div></div>
        <div class="kpi"><div>Net PnL (USD)</div><div class="v" id="arbNet">—</div></div>
      </div>
    </div>
  </div>

  <!-- FUNDING ARB TAB -->
  <div id="tab-fundarb" class="tab-panel">
    <div class="card">
      <div class="dash-title">
        <h2>Funding rate arb calculator</h2>
        <div class="muted">Long one venue, short the other — uses live funding + each venue’s interval</div>
      </div>

      <div class="grid grid-2" style="margin-top:12px;">
        <div>
          <label>Asset</label>
          <select id="faAsset"></select>
        </div>
        <div>
          <label>Notional (USD) per leg</label>
          <input id="faNotional" type="number" value="100000" min="0" step="1000" />
        </div>

        <div>
          <label>Long venue</label>
          <select id="faLongEx"></select>
        </div>
        <div>
          <label>Short venue</label>
          <select id="faShortEx"></select>
        </div>

        <div>
          <label>Holding period (hours)</label>
          <input id="faHoldHours" type="number" value="24" min="0" step="1" />
        </div>
        <div>
          <label>Total costs (bps) — fees + slippage</label>
          <input id="faCostsBps" type="number" value="3" step="0.1" />
        </div>
      </div>

      <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;">
        <button class="btn" id="faRecalc">Recalculate</button>
        <div class="muted">Assumes “positive funding = longs pay shorts”. If inverted on a venue, tell me and I’ll flip it.</div>
      </div>

      <div class="grid grid-3" style="margin-top:14px;">
        <div class="kpi"><div>Long funding / interval</div><div class="v" id="faLongFund">—</div></div>
        <div class="kpi"><div>Long interval</div><div class="v" id="faLongInt">—</div></div>
        <div class="kpi"><div>Long windows</div><div class="v" id="faLongWin">—</div></div>

        <div class="kpi"><div>Short funding / interval</div><div class="v" id="faShortFund">—</div></div>
        <div class="kpi"><div>Short interval</div><div class="v" id="faShortInt">—</div></div>
        <div class="kpi"><div>Short windows</div><div class="v" id="faShortWin">—</div></div>

        <div class="kpi"><div>Funding PnL (USD)</div><div class="v" id="faFundingPnl">—</div></div>
        <div class="kpi"><div>Costs (USD)</div><div class="v" id="faCosts">—</div></div>
        <div class="kpi"><div>Net (USD)</div><div class="v" id="faNet">—</div></div>
      </div>
    </div>
  </div>

  <!-- DAILY INSIGHTS TAB -->
  <div id="tab-daily" class="tab-panel">
    <div class="card">
      <div class="dash-title">
        <h2>Daily Insights (last 24h)</h2>
        <div class="muted" id="dailyStatus">Collecting data…</div>
      </div>

      <table>
        <thead>
          <tr>
            <th>Insight</th>
            <th>Coin</th>
            <th>Action</th>
            <th class="right">Metric</th>
            <th class="right">Observed</th>
          </tr>
        </thead>
        <tbody id="dailyRows">
          <tr><td colspan="5" class="muted">Waiting for data…</td></tr>
        </tbody>
      </table>

      <div class="muted" style="margin-top:10px;">
        Note: “best in last 24h” is based on data observed in your browser while the site is running (stored in localStorage).
      </div>
    </div>
  </div>

<script>
  // === set this to your worker ===
  const PROXY_BASE = "https://purple-sky-264e.jasper-cooney.workers.dev/?url=";

  const BPS_HIGHLIGHT = 5;
  const PRICES_REFRESH_MS = 3000;
  const FUNDING_REFRESH_MS = 60000;

  // 24h high spread across SELECTED exchanges (minute buckets)
  const HIGH_WINDOW_MINUTES = 24 * 60;
  const HIGH_STORE_KEY = "perpinsights_24h_high_spread_bps_v2";

  // Daily Insights store (24h)
  const DAILY_STORE_KEY = "perpinsights_daily_insights_v1";
  const DAILY_WINDOW_MINUTES = 24 * 60;

  // Same coins you currently had
  const COINS = ["BTC","ETH","SOL","XRP","ZEC","DOGE","ADA","LINK","AVAX","LTC","BCH","DOT"];

  // Exchange list
  const EXCHANGES = [
    { key:"hyper",  name:"Hyperliquid" },
    { key:"aster",  name:"Aster" },
    { key:"kraken", name:"Kraken" },
    { key:"okx",    name:"OKX" },
  ];

  // Symbol mappings per exchange
  const MAP = {
    hyper:  { BTC:"BTC", ETH:"ETH", SOL:"SOL", XRP:"XRP", ZEC:"ZEC", DOGE:"DOGE", ADA:"ADA", LINK:"LINK", AVAX:"AVAX", LTC:"LTC", BCH:"BCH", DOT:"DOT" },
    aster:  { BTC:"BTCUSDT", ETH:"ETHUSDT", SOL:"SOLUSDT", XRP:"XRPUSDT", ZEC:"ZECUSDT", DOGE:"DOGEUSDT", ADA:"ADAUSDT", LINK:"LINKUSDT", AVAX:"AVAXUSDT", LTC:"LTCUSDT", BCH:"BCHUSDT", DOT:"DOTUSDT" },
    okx:    { BTC:"BTC-USDT-SWAP", ETH:"ETH-USDT-SWAP", SOL:"SOL-USDT-SWAP", XRP:"XRP-USDT-SWAP", ZEC:"ZEC-USDT-SWAP", DOGE:"DOGE-USDT-SWAP", ADA:"ADA-USDT-SWAP", LINK:"LINK-USDT-SWAP", AVAX:"AVAX-USDT-SWAP", LTC:"LTC-USDT-SWAP", BCH:"BCH-USDT-SWAP", DOT:"DOT-USDT-SWAP" },
    // Kraken Futures perpetuals commonly use XBT not BTC
    kraken: { BTC:"PF_XBTUSD", ETH:"PF_ETHUSD", SOL:"PF_SOLUSD", XRP:"PF_XRPUSD", ZEC:"PF_ZECUSD", DOGE:"PF_DOGEUSD", ADA:"PF_ADAUSD", LINK:"PF_LINKUSD", AVAX:"PF_AVAXUSD", LTC:"PF_LTCUSD", BCH:"PF_BCHUSD", DOT:"PF_DOTUSD" },
  };

  // ===== DOM =====
  const exchChecks = document.getElementById("exchChecks");
  const coinChecks = document.getElementById("coinChecks");
  const filterStatus = document.getElementById("filterStatus");

  const pricesHead = document.getElementById("pricesHead");
  const priceRows = document.getElementById("priceRows");
  const priceStatus = document.getElementById("priceStatus");

  const fundingHead = document.getElementById("fundingHead");
  const fundingRows = document.getElementById("fundingRows");
  const fundingStatus = document.getElementById("fundingStatus");

  const arbAsset = document.getElementById("arbAsset");
  const arbBuyEx = document.getElementById("arbBuyEx");
  const arbSellEx = document.getElementById("arbSellEx");
  const arbNotional = document.getElementById("arbNotional");
  const arbConvBps = document.getElementById("arbConvBps");
  const arbCostsBps = document.getElementById("arbCostsBps");
  const arbRecalc = document.getElementById("arbRecalc");
  const arbCurBps = document.getElementById("arbCurBps");
  const arbGross = document.getElementById("arbGross");
  const arbCosts = document.getElementById("arbCosts");
  const arbNet = document.getElementById("arbNet");

  const faAsset = document.getElementById("faAsset");
  const faLongEx = document.getElementById("faLongEx");
  const faShortEx = document.getElementById("faShortEx");
  const faNotional = document.getElementById("faNotional");
  const faHoldHours = document.getElementById("faHoldHours");
  const faCostsBps = document.getElementById("faCostsBps");
  const faRecalc = document.getElementById("faRecalc");
  const faLongFund = document.getElementById("faLongFund");
  const faLongInt = document.getElementById("faLongInt");
  const faLongWin = document.getElementById("faLongWin");
  const faShortFund = document.getElementById("faShortFund");
  const faShortInt = document.getElementById("faShortInt");
  const faShortWin = document.getElementById("faShortWin");
  const faFundingPnl = document.getElementById("faFundingPnl");
  const faCosts = document.getElementById("faCosts");
  const faNet = document.getElementById("faNet");

  const dailyStatus = document.getElementById("dailyStatus");
  const dailyRows = document.getElementById("dailyRows");

  // ===== Tabs =====
  function initTabs() {
    const btns = document.querySelectorAll(".tab-btn");
    const panels = {
      prices: document.getElementById("tab-prices"),
      funding: document.getElementById("tab-funding"),
      arb: document.getElementById("tab-arb"),
      fundarb: document.getElementById("tab-fundarb"),
      daily: document.getElementById("tab-daily"),
    };
    btns.forEach(b => {
      b.addEventListener("click", () => {
        btns.forEach(x => x.classList.remove("active"));
        b.classList.add("active");
        Object.values(panels).forEach(p => p.classList.remove("active"));
        panels[b.dataset.tab].classList.add("active");
        if (b.dataset.tab === "arb") renderArb();
        if (b.dataset.tab === "fundarb") renderFundingArb();
        if (b.dataset.tab === "daily") renderDailyInsights();
      });
    });
  }

  // ===== Filters state =====
  const FILTER_KEY = "perpinsights_filters_v1";
  let selectedEx = new Set(EXCHANGES.map(x => x.key));
  let selectedCoins = new Set(COINS);

  function saveFilters() {
    try {
      localStorage.setItem(FILTER_KEY, JSON.stringify({
        ex: [...selectedEx],
        coins: [...selectedCoins],
      }));
    } catch {}
  }
  function loadFilters() {
    try {
      const raw = localStorage.getItem(FILTER_KEY);
      if (!raw) return;
      const j = JSON.parse(raw);
      if (Array.isArray(j.ex)) selectedEx = new Set(j.ex);
      if (Array.isArray(j.coins)) selectedCoins = new Set(j.coins);
    } catch {}
  }

  function renderFilterUI() {
    exchChecks.innerHTML = EXCHANGES.map(e => `
      <label class="chk">
        <input type="checkbox" data-ex="${e.key}" ${selectedEx.has(e.key) ? "checked" : ""}/>
        ${e.name}
      </label>
    `).join("");

    coinChecks.innerHTML = COINS.map(c => `
      <label class="chk">
        <input type="checkbox" data-coin="${c}" ${selectedCoins.has(c) ? "checked" : ""}/>
        ${c}
      </label>
    `).join("");

    exchChecks.querySelectorAll("input[type=checkbox]").forEach(cb => {
      cb.addEventListener("change", () => {
        const k = cb.dataset.ex;
        cb.checked ? selectedEx.add(k) : selectedEx.delete(k);
      });
    });

    coinChecks.querySelectorAll("input[type=checkbox]").forEach(cb => {
      cb.addEventListener("change", () => {
        const k = cb.dataset.coin;
        cb.checked ? selectedCoins.add(k) : selectedCoins.delete(k);
      });
    });
  }

  function setAllEx(on) {
    selectedEx = new Set(on ? EXCHANGES.map(x=>x.key) : []);
    renderFilterUI();
  }
  function setAllCoins(on) {
    selectedCoins = new Set(on ? COINS : []);
    renderFilterUI();
  }

  document.getElementById("exAll").onclick = () => setAllEx(true);
  document.getElementById("exNone").onclick = () => setAllEx(false);
  document.getElementById("cAll").onclick = () => setAllCoins(true);
  document.getElementById("cNone").onclick = () => setAllCoins(false);

  document.getElementById("applyFilters").onclick = () => {
    if (selectedEx.size < 1) { alert("Select at least 1 exchange"); return; }
    if (selectedCoins.size < 1) { alert("Select at least 1 coin"); return; }

    saveFilters();
    filterStatus.textContent = `Applied: ${selectedEx.size} exchanges, ${selectedCoins.size} coins.`;
    buildTables();
    refreshAllDropdowns();
    refreshPrices();
    refreshFunding();
  };

  document.getElementById("resetFilters").onclick = () => {
    selectedEx = new Set(EXCHANGES.map(x=>x.key));
    selectedCoins = new Set(COINS);
    saveFilters();
    renderFilterUI();
    document.getElementById("applyFilters").click();
  };

  // ===== Helpers =====
  function nowMinuteEpoch() { return Math.floor(Date.now() / 60000); }

  function exName(exKey) {
    return (EXCHANGES.find(e => e.key === exKey)?.name) || exKey;
  }

  function fmtUsd(x) {
    if (x === undefined || x === null || x === "" || Number.isNaN(Number(x))) return "—";
    const n = Number(x);
    return n >= 1
      ? "$" + n.toLocaleString(undefined, { maximumFractionDigits: 2 })
      : "$" + n.toLocaleString(undefined, { maximumFractionDigits: 6 });
  }
  function fmtBpsAbs(x) {
    if (!Number.isFinite(x)) return "—";
    const abs = Math.abs(x);
    return abs.toFixed(abs < 10 ? 2 : 1) + " bps";
  }
  function fmtBpsSigned(x) {
    if (!Number.isFinite(x)) return { text:"—", cls:"" };
    const abs = Math.abs(x);
    return { text: (x>=0?"+":"−") + abs.toFixed(abs < 10 ? 2 : 1) + " bps", cls: x>0?"pos":(x<0?"neg":"") };
  }
  function fmtFunding(rate) {
    if (!Number.isFinite(rate)) return "—";
    const p = rate * 100;
    return (p>=0?"":"−") + Math.abs(p).toFixed(Math.abs(p) < 0.01 ? 4 : 3) + "%";
  }
  function fmtIntervalH(h) {
    if (!Number.isFinite(h) || h<=0) return "—";
    return h.toFixed(h < 10 ? 2 : 1) + "h";
  }
  function aprFromRate(ratePerWindow, intervalH) {
    if (!Number.isFinite(ratePerWindow) || !Number.isFinite(intervalH) || intervalH<=0) return "—";
    const windowsPerYear = (365*24)/intervalH;
    const apr = ratePerWindow * windowsPerYear * 100;
    return (apr>=0?"":"−") + Math.abs(apr).toFixed(Math.abs(apr) < 1 ? 3 : 2) + "%";
  }
  function money(x) {
    if (!Number.isFinite(x)) return "—";
    return (x>=0?"":"−") + "$" + Math.abs(x).toLocaleString(undefined, { maximumFractionDigits: 2 });
  }

  async function fetchJson(url, options) {
    const r = await fetch(PROXY_BASE + encodeURIComponent(url), { cache:"no-store", ...(options||{}) });
    if (!r.ok) throw new Error(String(r.status));
    return r.json();
  }

  // ===== Local storage: 24h High spread (per coin, minute bucket) =====
  let highStore = {}; // { [coin]: [{m, s}] } s=spreadAbsBps

  function loadHighStore() {
    try { highStore = JSON.parse(localStorage.getItem(HIGH_STORE_KEY) || "{}"); } catch { highStore = {}; }
  }
  function saveHighStore() {
    try { localStorage.setItem(HIGH_STORE_KEY, JSON.stringify(highStore)); } catch {}
  }
  function pruneHighStore() {
    const cutoff = nowMinuteEpoch() - HIGH_WINDOW_MINUTES;
    for (const c of Object.keys(highStore)) {
      const arr = Array.isArray(highStore[c]) ? highStore[c] : [];
      highStore[c] = arr.filter(x => x && Number.isFinite(x.m) && x.m >= cutoff && Number.isFinite(x.s));
      if (highStore[c].length === 0) delete highStore[c];
    }
  }
  function updateHigh(coin, spreadAbsBps) {
    if (!Number.isFinite(spreadAbsBps)) return;
    const m = nowMinuteEpoch();
    if (!Array.isArray(highStore[coin])) highStore[coin] = [];
    const arr = highStore[coin];
    const last = arr.length ? arr[arr.length - 1] : null;
    if (last && last.m === m) {
      if (spreadAbsBps > last.s) last.s = spreadAbsBps;
    } else {
      arr.push({ m, s: spreadAbsBps });
    }
    const cutoff = m - HIGH_WINDOW_MINUTES;
    while (arr.length && arr[0].m < cutoff) arr.shift();
  }
  function get24hHigh(coin) {
    const arr = highStore[coin];
    if (!Array.isArray(arr) || !arr.length) return null;
    let best = arr[0];
    for (const x of arr) if (x && Number.isFinite(x.s) && x.s > best.s) best = x;
    return best;
  }

  // ===== Daily Insights store =====
  // dailyStore = {
  //   spread: { [coin]: [{m, bps, buyEx, sellEx}] },
  //   funding:{ [coin]: [{m, apr, longEx, shortEx}] }
  // }
  let dailyStore = { spread: {}, funding: {} };

  function loadDailyStore() {
    try {
      dailyStore = JSON.parse(localStorage.getItem(DAILY_STORE_KEY) || '{"spread":{},"funding":{}}');
      if (!dailyStore.spread) dailyStore.spread = {};
      if (!dailyStore.funding) dailyStore.funding = {};
    } catch {
      dailyStore = { spread: {}, funding: {} };
    }
  }
  function saveDailyStore() {
    try { localStorage.setItem(DAILY_STORE_KEY, JSON.stringify(dailyStore)); } catch {}
  }
  function pruneDailyStore() {
    const cutoff = nowMinuteEpoch() - DAILY_WINDOW_MINUTES;

    for (const coin of Object.keys(dailyStore.spread || {})) {
      const arr = Array.isArray(dailyStore.spread[coin]) ? dailyStore.spread[coin] : [];
      dailyStore.spread[coin] = arr.filter(x => x && Number.isFinite(x.m) && x.m >= cutoff && Number.isFinite(x.bps));
      if (!dailyStore.spread[coin].length) delete dailyStore.spread[coin];
    }

    for (const coin of Object.keys(dailyStore.funding || {})) {
      const arr = Array.isArray(dailyStore.funding[coin]) ? dailyStore.funding[coin] : [];
      dailyStore.funding[coin] = arr.filter(x => x && Number.isFinite(x.m) && x.m >= cutoff && Number.isFinite(x.apr));
      if (!dailyStore.funding[coin].length) delete dailyStore.funding[coin];
    }
  }

  function updateDailySpread(coin, spreadBpsAbs, buyEx, sellEx) {
    if (!Number.isFinite(spreadBpsAbs)) return;
    const m = nowMinuteEpoch();
    if (!Array.isArray(dailyStore.spread[coin])) dailyStore.spread[coin] = [];
    const arr = dailyStore.spread[coin];
    const last = arr.length ? arr[arr.length - 1] : null;

    if (last && last.m === m) {
      if (spreadBpsAbs > last.bps) {
        last.bps = spreadBpsAbs;
        last.buyEx = buyEx;
        last.sellEx = sellEx;
      }
    } else {
      arr.push({ m, bps: spreadBpsAbs, buyEx, sellEx });
    }

    const cutoff = m - DAILY_WINDOW_MINUTES;
    while (arr.length && arr[0].m < cutoff) arr.shift();
  }

  function updateDailyFunding(coin, netAprPct, longEx, shortEx) {
    if (!Number.isFinite(netAprPct)) return;
    const m = nowMinuteEpoch();
    if (!Array.isArray(dailyStore.funding[coin])) dailyStore.funding[coin] = [];
    const arr = dailyStore.funding[coin];
    const last = arr.length ? arr[arr.length - 1] : null;

    if (last && last.m === m) {
      if (netAprPct > last.apr) {
        last.apr = netAprPct;
        last.longEx = longEx;
        last.shortEx = shortEx;
      }
    } else {
      arr.push({ m, apr: netAprPct, longEx, shortEx });
    }

    const cutoff = m - DAILY_WINDOW_MINUTES;
    while (arr.length && arr[0].m < cutoff) arr.shift();
  }

  function bestSpread24h() {
    pruneDailyStore();
    let best = null; // {coin, m, bps, buyEx, sellEx}
    for (const [coin, arr] of Object.entries(dailyStore.spread || {})) {
      for (const x of (arr || [])) {
        if (!x || !Number.isFinite(x.bps)) continue;
        if (!best || x.bps > best.bps) best = { coin, ...x };
      }
    }
    return best;
  }

  function bestFunding24h() {
    pruneDailyStore();
    let best = null; // {coin, m, apr, longEx, shortEx}
    for (const [coin, arr] of Object.entries(dailyStore.funding || {})) {
      for (const x of (arr || [])) {
        if (!x || !Number.isFinite(x.apr)) continue;
        if (!best || x.apr > best.apr) best = { coin, ...x };
      }
    }
    return best;
  }

  function renderDailyInsights() {
    if (!dailyRows || !dailyStatus) return;

    const s = bestSpread24h();
    const f = bestFunding24h();

    const rows = [];

    if (s) {
      rows.push(`
        <tr>
          <td><b>Spread Convergence Arb</b></td>
          <td>${s.coin}</td>
          <td>Buy <b>${exName(s.buyEx)}</b> / Sell <b>${exName(s.sellEx)}</b></td>
          <td class="right">${fmtBpsAbs(s.bps)}</td>
          <td class="right">${new Date(s.m * 60000).toLocaleString()}</td>
        </tr>
      `);
    } else {
      rows.push(`
        <tr>
          <td><b>Spread Convergence Arb</b></td>
          <td>—</td>
          <td class="muted">Waiting for price history…</td>
          <td class="right">—</td>
          <td class="right">—</td>
        </tr>
      `);
    }

    if (f) {
      const pct = f.apr;
      rows.push(`
        <tr>
          <td><b>Funding Rate Arb</b></td>
          <td>${f.coin}</td>
          <td>Long <b>${exName(f.longEx)}</b> / Short <b>${exName(f.shortEx)}</b></td>
          <td class="right">${(pct).toFixed(Math.abs(pct) < 1 ? 3 : 2)}%</td>
          <td class="right">${new Date(f.m * 60000).toLocaleString()}</td>
        </tr>
      `);
    } else {
      rows.push(`
        <tr>
          <td><b>Funding Rate Arb</b></td>
          <td>—</td>
          <td class="muted">Waiting for funding history…</td>
          <td class="right">—</td>
          <td class="right">—</td>
        </tr>
      `);
    }

    dailyRows.innerHTML = rows.join("");
    dailyStatus.textContent = `Updated: ${new Date().toLocaleTimeString()} (last 24h window)`;
  }

  // ===== Data caches =====
  // prices[exchange][coin] = priceNumber
  const prices = {};
  // funding[exchange][coin] = { rate, intervalH }
  const funding = {};

  // ===== Fetchers =====
  async function loadHyperliquid() {
    const j = await fetchJson("https://api.hyperliquid.xyz/info", {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ type:"metaAndAssetCtxs" })
    });
    const meta = j[0], ctxs = j[1];
    const map = new Map();
    meta.universe.forEach((u,i) => map.set(u.name, ctxs[i] || {}));

    for (const coin of COINS) {
      const sym = MAP.hyper[coin];
      if (!sym) continue;
      const c = map.get(sym);
      const px = Number(c?.markPx);
      const fr = Number(c?.funding);
      if (!prices.hyper) prices.hyper = {};
      if (!funding.hyper) funding.hyper = {};
      if (Number.isFinite(px)) prices.hyper[coin] = px;
      if (Number.isFinite(fr)) funding.hyper[coin] = { rate: fr, intervalH: 1 }; // hourly
    }
  }

  async function loadAster() {
    const [p, prem] = await Promise.all([
      fetchJson("https://fapi.asterdex.com/fapi/v1/ticker/price"),
      fetchJson("https://fapi.asterdex.com/fapi/v1/premiumIndex")
    ]);

    const pMap = new Map();
    if (Array.isArray(p)) for (const x of p) pMap.set(x.symbol, x.price);

    const fMap = new Map();
    if (Array.isArray(prem)) for (const x of prem) fMap.set(x.symbol, x);

    for (const coin of COINS) {
      const sym = MAP.aster[coin];
      if (!sym) continue;

      const px = Number(pMap.get(sym));
      if (!prices.aster) prices.aster = {};
      if (Number.isFinite(px)) prices.aster[coin] = px;

      const obj = fMap.get(sym);
      const r = Number(obj?.lastFundingRate ?? obj?.fundingRate ?? obj?.funding);
      let intervalH = null;
      const last = Number(obj?.lastFundingTime);
      const next = Number(obj?.nextFundingTime);
      if (Number.isFinite(last) && Number.isFinite(next) && next > last) intervalH = (next-last)/3600000;
      if (!Number.isFinite(intervalH) || intervalH<=0) intervalH = 8;

      if (!funding.aster) funding.aster = {};
      if (Number.isFinite(r)) funding.aster[coin] = { rate: r, intervalH };
    }
  }

  async function loadOKX() {
    const tickTasks = [];
    const fundTasks = [];

    for (const coin of COINS) {
      const instId = MAP.okx[coin];
      if (!instId) continue;

      tickTasks.push((async () => {
        const j = await fetchJson(`https://www.okx.com/api/v5/market/ticker?instId=${encodeURIComponent(instId)}`);
        const d = j?.data?.[0];
        const px = Number(d?.last ?? d?.markPx ?? d?.idxPx);
        if (!prices.okx) prices.okx = {};
        if (Number.isFinite(px)) prices.okx[coin] = px;
      })());

      fundTasks.push((async () => {
        const j = await fetchJson(`https://www.okx.com/api/v5/public/funding-rate?instId=${encodeURIComponent(instId)}`);
        const d = j?.data?.[0];
        const r = Number(d?.fundingRate);
        const ft = Number(d?.fundingTime);
        const nft = Number(d?.nextFundingTime);
        let intervalH = null;
        if (Number.isFinite(ft) && Number.isFinite(nft) && nft > ft) intervalH = (nft-ft)/3600000;
        if (!Number.isFinite(intervalH) || intervalH<=0) intervalH = 8;
        if (!funding.okx) funding.okx = {};
        if (Number.isFinite(r)) funding.okx[coin] = { rate: r, intervalH };
      })());
    }

    await Promise.allSettled([...tickTasks, ...fundTasks]);
  }

  async function loadKrakenFutures() {
    const j = await fetchJson("https://futures.kraken.com/derivatives/api/v3/tickers");
    const arr = j?.tickers || j?.result || j;
    const tMap = new Map();
    if (Array.isArray(arr)) {
      for (const t of arr) {
        const sym = t?.symbol || t?.instrument || t?.product_id;
        if (sym) tMap.set(sym, t);
      }
    }

    if (!prices.kraken) prices.kraken = {};
    if (!funding.kraken) funding.kraken = {};

    for (const coin of COINS) {
      const sym = MAP.kraken[coin];
      const t = tMap.get(sym);
      if (!t) continue;

      const px = Number(t?.markPrice ?? t?.mark_price ?? t?.last ?? t?.lastPrice ?? t?.last_price);
      if (Number.isFinite(px)) prices.kraken[coin] = px;

      const fr = Number(t?.fundingRate ?? t?.funding_rate ?? t?.funding_rate_prediction ?? t?.fundingRatePrediction);
      if (Number.isFinite(fr)) funding.kraken[coin] = { rate: fr, intervalH: 1 };
    }
  }

  async function refreshPrices() {
    const start = Date.now();
    priceStatus.textContent = "Updating…";
    priceStatus.className = "muted";

    for (const ex of Object.keys(prices)) prices[ex] = {};

    const tasks = [];
    if (selectedEx.has("hyper")) tasks.push(loadHyperliquid());
    if (selectedEx.has("aster")) tasks.push(loadAster());
    if (selectedEx.has("okx")) tasks.push(loadOKX());
    if (selectedEx.has("kraken")) tasks.push(loadKrakenFutures());

    await Promise.allSettled(tasks);

    renderPrices();
    renderArb();
    const ms = Date.now() - start;
    priceStatus.textContent = `Updated: ${new Date().toLocaleTimeString()} (${ms} ms)`;
    priceStatus.className = "muted ok";
  }

  async function refreshFunding() {
    const start = Date.now();
    fundingStatus.textContent = "Updating…";
    fundingStatus.className = "muted";

    for (const ex of Object.keys(funding)) funding[ex] = {};

    const tasks = [];
    if (selectedEx.has("hyper")) tasks.push(loadHyperliquid());
    if (selectedEx.has("aster")) tasks.push(loadAster());
    if (selectedEx.has("okx")) tasks.push(loadOKX());
    if (selectedEx.has("kraken")) tasks.push(loadKrakenFutures());

    await Promise.allSettled(tasks);

    renderFunding();
    renderFundingArb();

    // Update Daily Insights funding based on current snapshot
    updateDailyFundingFromCurrent();
    pruneDailyStore();
    saveDailyStore();
    renderDailyInsights();

    const ms = Date.now() - start;
    fundingStatus.textContent = `Updated: ${new Date().toLocaleTimeString()} (${ms} ms)`;
    fundingStatus.className = "muted ok";
  }

  // ===== Render tables based on filters =====
  function buildTables() {
    const exList = EXCHANGES.filter(e => selectedEx.has(e.key));
    const coinsList = COINS.filter(c => selectedCoins.has(c));

    pricesHead.innerHTML = `
      <tr>
        <th>Asset</th>
        ${exList.map(e => `<th class="right">${e.name}</th>`).join("")}
        <th class="right">Spread (bps)</th>
        <th class="right">24h High (bps)</th>
      </tr>
    `;

    fundingHead.innerHTML = `
      <tr>
        <th>Asset</th>
        ${exList.map(e => `
          <th class="right">${e.name} Funding</th>
          <th class="right">${e.name} Interval</th>
          <th class="right">${e.name} 365-day</th>
        `).join("")}
      </tr>
    `;

    priceRows.innerHTML = coinsList.map(c => `<tr><td class="asset">${c}</td></tr>`).join("");
    fundingRows.innerHTML = coinsList.map(c => `<tr><td class="asset">${c}</td></tr>`).join("");
  }

  function renderPrices() {
    pruneHighStore();
    pruneDailyStore();

    const exList = EXCHANGES.filter(e => selectedEx.has(e.key));
    const coinsList = COINS.filter(c => selectedCoins.has(c));

    priceRows.innerHTML = coinsList.map(coin => {
      const pxs = []; // [{ex, p}]
      const cells = exList.map(e => {
        const p = prices?.[e.key]?.[coin];
        if (Number.isFinite(p)) pxs.push({ ex: e.key, p });
        return `<td class="right">${fmtUsd(p)}</td>`;
      }).join("");

      let spreadBps = null;
      let buyEx = null;
      let sellEx = null;

      if (pxs.length >= 2) {
        pxs.sort((a,b) => a.p - b.p);
        const min = pxs[0];
        const max = pxs[pxs.length - 1];
        if (min.p > 0) {
          spreadBps = 10000 * (max.p - min.p) / min.p;
          buyEx = min.ex;
          sellEx = max.ex;
        }
      }

      if (Number.isFinite(spreadBps)) {
        updateHigh(coin, spreadBps);
        updateDailySpread(coin, spreadBps, buyEx, sellEx);
      }

      const hi = get24hHigh(coin);
      const hot = Number.isFinite(spreadBps) && spreadBps >= BPS_HIGHLIGHT ? "hot" : "";
      const spreadTxt = Number.isFinite(spreadBps) ? fmtBpsAbs(spreadBps) : "—";
      const highTxt = hi ? fmtBpsAbs(hi.s) : "—";
      const title = hi ? `title="Observed at: ${new Date(hi.m*60000).toLocaleString()}"` : "";

      return `
        <tr class="${hot}">
          <td class="asset">${coin}</td>
          ${cells}
          <td class="right">${spreadTxt}</td>
          <td class="right" ${title}>${highTxt}</td>
        </tr>
      `;
    }).join("");

    saveHighStore();
    saveDailyStore();
    renderDailyInsights();
  }

  function renderFunding() {
    const exList = EXCHANGES.filter(e => selectedEx.has(e.key));
    const coinsList = COINS.filter(c => selectedCoins.has(c));

    fundingRows.innerHTML = coinsList.map(coin => {
      const cells = exList.map(e => {
        const rec = funding?.[e.key]?.[coin];
        const r = Number(rec?.rate);
        const ih = Number(rec?.intervalH);
        return `
          <td class="right">${fmtFunding(r)}</td>
          <td class="right">${fmtIntervalH(ih)}</td>
          <td class="right">${aprFromRate(r, ih)}</td>
        `;
      }).join("");

      return `<tr><td class="asset">${coin}</td>${cells}</tr>`;
    }).join("");
  }

  // ===== Dropdowns / calculators =====
  function refreshAllDropdowns() {
    const coinsList = COINS.filter(c => selectedCoins.has(c));
    const exList = EXCHANGES.filter(e => selectedEx.has(e.key));

    arbAsset.innerHTML = coinsList.map(c => `<option value="${c}">${c}</option>`).join("");
    faAsset.innerHTML = coinsList.map(c => `<option value="${c}">${c}</option>`).join("");

    arbBuyEx.innerHTML = exList.map(e => `<option value="${e.key}">${e.name}</option>`).join("");
    arbSellEx.innerHTML = exList.map(e => `<option value="${e.key}">${e.name}</option>`).join("");

    faLongEx.innerHTML = exList.map(e => `<option value="${e.key}">${e.name}</option>`).join("");
    faShortEx.innerHTML = exList.map(e => `<option value="${e.key}">${e.name}</option>`).join("");

    if (coinsList.length) {
      if (!coinsList.includes(arbAsset.value)) arbAsset.value = coinsList[0];
      if (!coinsList.includes(faAsset.value)) faAsset.value = coinsList[0];
    }
    if (exList.length >= 2) {
      arbBuyEx.value = exList[0].key;
      arbSellEx.value = exList[1].key;
      faLongEx.value = exList[0].key;
      faShortEx.value = exList[1].key;
    }
  }

  function renderArb() {
    const coin = arbAsset.value;
    const buy = arbBuyEx.value;
    const sell = arbSellEx.value;

    const buyPx = Number(prices?.[buy]?.[coin]);
    const sellPx = Number(prices?.[sell]?.[coin]);

    let curBps = null;
    if (Number.isFinite(buyPx) && Number.isFinite(sellPx) && buyPx > 0) {
      curBps = 10000 * (sellPx - buyPx) / buyPx;
    }
    arbCurBps.textContent = Number.isFinite(curBps) ? fmtBpsSigned(curBps).text : "—";

    const notional = Number(arbNotional.value || 0);
    const conv = Number(arbConvBps.value || 0);
    const costsBps = Number(arbCostsBps.value || 0);

    const gross = notional * (conv / 10000);
    const costs = notional * (costsBps / 10000);
    const net = gross - costs;

    arbGross.textContent = money(gross);
    arbCosts.textContent = money(costs);
    arbNet.textContent = money(net);
    arbNet.className = "v " + (net >= 0 ? "pos" : "neg");
  }

  function renderFundingArb() {
    const coin = faAsset.value;
    const longEx = faLongEx.value;
    const shortEx = faShortEx.value;

    const longRec = funding?.[longEx]?.[coin];
    const shortRec = funding?.[shortEx]?.[coin];

    const longRate = Number(longRec?.rate);
    const shortRate = Number(shortRec?.rate);
    const longInt = Number(longRec?.intervalH);
    const shortInt = Number(shortRec?.intervalH);

    const holdH = Math.max(0, Number(faHoldHours.value || 0));
    const notional = Number(faNotional.value || 0);
    const costsBps = Number(faCostsBps.value || 0);

    const longWin = (Number.isFinite(longInt) && longInt > 0) ? (holdH / longInt) : null;
    const shortWin = (Number.isFinite(shortInt) && shortInt > 0) ? (holdH / shortInt) : null;

    faLongFund.textContent = fmtFunding(longRate);
    faLongInt.textContent = fmtIntervalH(longInt);
    faLongWin.textContent = (longWin === null) ? "—" : longWin.toFixed(2);

    faShortFund.textContent = fmtFunding(shortRate);
    faShortInt.textContent = fmtIntervalH(shortInt);
    faShortWin.textContent = (shortWin === null) ? "—" : shortWin.toFixed(2);

    if (longEx === shortEx) {
      faFundingPnl.textContent = "—";
      faCosts.textContent = "—";
      faNet.textContent = "Choose different venues";
      faNet.className = "v";
      return;
    }

    if (!Number.isFinite(longRate) || !Number.isFinite(shortRate) || !Number.isFinite(longWin) || !Number.isFinite(shortWin)) {
      faFundingPnl.textContent = "—";
      faCosts.textContent = "—";
      faNet.textContent = "Waiting for funding…";
      faNet.className = "v";
      return;
    }

    // Convention: positive funding = longs pay shorts
    const pnlLong = notional * (-longRate) * longWin;
    const pnlShort = notional * (+shortRate) * shortWin;
    const fundingPnl = pnlLong + pnlShort;

    const costs = notional * (costsBps / 10000);
    const net = fundingPnl - costs;

    faFundingPnl.textContent = money(fundingPnl);
    faCosts.textContent = money(costs);
    faNet.textContent = money(net);
    faNet.className = "v " + (net >= 0 ? "pos" : "neg");
  }

  // ===== Daily funding “best pair” from current snapshot =====
  function updateDailyFundingFromCurrent() {
    const exList = EXCHANGES.filter(e => selectedEx.has(e.key));
    const coinsList = COINS.filter(c => selectedCoins.has(c));

    for (const coin of coinsList) {
      const perHour = []; // {ex, rph}
      for (const e of exList) {
        const rec = funding?.[e.key]?.[coin];
        const r = Number(rec?.rate);
        const ih = Number(rec?.intervalH);
        if (!Number.isFinite(r) || !Number.isFinite(ih) || ih <= 0) continue;
        perHour.push({ ex: e.key, rph: r / ih });
      }
      if (perHour.length < 2) continue;

      // Best carry: long the most negative rph, short the most positive rph
      perHour.sort((a,b) => a.rph - b.rph);
      const bestLong = perHour[0];
      const bestShort = perHour[perHour.length - 1];

      const netPerHour = (-bestLong.rph) + (bestShort.rph);
      const netAprPct = netPerHour * 24 * 365 * 100;

      if (Number.isFinite(netAprPct) && netAprPct > 0) {
        updateDailyFunding(coin, netAprPct, bestLong.ex, bestShort.ex);
      }
    }
  }

  // ===== Buttons/events =====
  arbRecalc.onclick = renderArb;
  faRecalc.onclick = renderFundingArb;

  ["change","input"].forEach(ev => {
    arbAsset.addEventListener(ev, renderArb);
    arbBuyEx.addEventListener(ev, renderArb);
    arbSellEx.addEventListener(ev, renderArb);
    arbNotional.addEventListener(ev, renderArb);
    arbConvBps.addEventListener(ev, renderArb);
    arbCostsBps.addEventListener(ev, renderArb);

    faAsset.addEventListener(ev, renderFundingArb);
    faLongEx.addEventListener(ev, renderFundingArb);
    faShortEx.addEventListener(ev, renderFundingArb);
    faNotional.addEventListener(ev, renderFundingArb);
    faHoldHours.addEventListener(ev, renderFundingArb);
    faCostsBps.addEventListener(ev, renderFundingArb);
  });

  // ===== Init =====
  function init() {
    initTabs();

    loadFilters();
    loadHighStore();
    loadDailyStore();

    pruneHighStore();
    pruneDailyStore();

    saveHighStore();
    saveDailyStore();

    renderFilterUI();
    buildTables();
    refreshAllDropdowns();

    refreshPrices();
    refreshFunding();
    renderDailyInsights();

    setInterval(refreshPrices, PRICES_REFRESH_MS);
    setInterval(refreshFunding, FUNDING_REFRESH_MS);
  }

  init();
</script>
</body>
</html>
